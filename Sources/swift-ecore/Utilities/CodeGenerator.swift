//
// CodeGenerator.swift
// swift-ecore
//
//  Created by Rene Hexel on 3/12/2025.
//  Copyright Â© 2025 Rene Hexel. All rights reserved.
//
import ECore
import Foundation

actor CodeGenerator {
    let language: String
    let outputDirectory: URL
    private var classCache: [UUID: EClass] = [:]
    private var enumCache: [UUID: EEnum] = [:]

    init(language: String, outputDirectory: URL) throws {
        guard ["swift", "cpp", "c", "llvm"].contains(language) else { throw GenerationError.unsupportedLanguage(language) }
        self.language = language
        self.outputDirectory = outputDirectory
    }

    func generate(from resource: Resource, verbose: Bool) async throws {
        if language == "swift" { try await generateSwift(from: resource, verbose: verbose) }
        else if language == "cpp" { try await generateCpp(from: resource, verbose: verbose) }
    }

    private func generateSwift(from resource: Resource, verbose: Bool) async throws {
        let objects = await resource.getRootObjects()
        classCache.removeAll()
        enumCache.removeAll()
        let referenceMap = await buildReferenceMap(from: objects, in: resource)
        let outputFile = outputDirectory.appendingPathComponent("Generated.swift")
        var content = "// Generated by Swift Ecore\nimport Foundation\nimport ECore\n"

        for obj in objects {
            if let pkg = await resolvePackage(obj, in: resource) {
                content += await generateSwiftPackage(from: pkg, in: resource, referenceMap: referenceMap)
                content += generateSwiftFactory(from: pkg)
                content += generateSwiftPackageDescriptor(from: pkg)
            } else if let cls = await resolveClass(obj, in: resource) {
                content += await generateSwiftClass(from: cls, in: resource, referenceMap: referenceMap)
            } else if let enm = await resolveEnum(obj, in: resource) {
                content += generateSwiftEnum(from: enm)
            }
        }
        try content.write(to: outputFile, atomically: true, encoding: .utf8)
    }

    private func buildReferenceMap(from objects: [any EObject], in resource: Resource) async -> [UUID: EReference] {
        var map: [UUID: EReference] = [:]
        for obj in objects {
            if let cls = await resolveClass(obj, in: resource) {
                for f in cls.eStructuralFeatures { if let r = f as? EReference { map[r.id] = r } }
            } else if let pkg = await resolvePackage(obj, in: resource) {
                for c in pkg.eClassifiers {
                    if let cO = c as? any EObject, let cC = await resolveClass(cO, in: resource) {
                        for f in cC.eStructuralFeatures { if let r = f as? EReference { map[r.id] = r } }
                    }
                }
            }
        }
        return map
    }

    private func resolvePackage(_ obj: any EObject, in resource: Resource) async -> EPackage? {
        if let p = obj as? EPackage { return p }
        guard let d = obj as? DynamicEObject, d.eClass.name == EcoreClassifier.ePackage.rawValue || d.eClass.name == EcoreDataType.eResource.rawValue else { return nil }
        var pkg = EPackage(id: d.id, name: d.eGet("name") as? String ?? "Unknown")
        if let ids = d.eGet(XMIElement.eClassifiers.rawValue) as? [UUID] {
            for id in ids { if let child = await resource.getObject(id), let c = await resolveClassifier(child, in: resource) { pkg.eClassifiers.append(c) } }
        }
        return pkg
    }

    private func resolveEnum(_ obj: any EObject, in resource: Resource) async -> EEnum? {
        if let e = obj as? EEnum { return e }
        if let cached = enumCache[obj.id] { return cached }
        guard let d = obj as? DynamicEObject, d.eClass.name == EcoreClassifier.eEnum.rawValue else { return nil }
        let name = d.eGet(XMIAttribute.name.rawValue) as? String ?? "Unknown"
        var lits: [EEnumLiteral] = []
        if let lIds = d.eGet(XMIElement.eLiterals.rawValue) as? [UUID] ?? d.eGet(XMIElement.eClassifiers.rawValue) as? [UUID] {
            for (index, id) in lIds.enumerated() {
                if let lObj = await resource.getObject(id), let dL = lObj as? DynamicEObject {
                    let lName = dL.eGet(XMIAttribute.name.rawValue) as? String ?? "unknown"
                    var lVal = dL.eGet(XMIAttribute.value.rawValue) as? Int ?? 0
                    if lVal == 0 && index > 0 { lVal = index }
                    lits.append(EEnumLiteral(id: dL.id, name: lName, value: lVal))
                }
            }
        }
        let enm = EEnum(id: d.id, name: name, literals: lits)
        enumCache[d.id] = enm
        return enm
    }

    private func resolveClass(_ obj: any EObject, in resource: Resource) async -> EClass? {
        if let c = obj as? EClass { return c }
        if let cached = classCache[obj.id] { return cached }
        guard let d = obj as? DynamicEObject, d.eClass.name == EcoreClassifier.eClass.rawValue else { return nil }
        var cls = EClass(id: d.id, name: d.eGet(XMIAttribute.name.rawValue) as? String ?? "Unknown", isAbstract: d.eGet(XMIAttribute.abstract.rawValue) as? Bool ?? false, isInterface: d.eGet(XMIAttribute.interface.rawValue) as? Bool ?? false)
        classCache[d.id] = cls
        if let ids = d.eGet(XMIElement.eStructuralFeatures.rawValue) as? [UUID] {
            for id in ids {
                if let child = await resource.getObject(id), let dC = child as? DynamicEObject {
                    let n = dC.eGet(XMIAttribute.name.rawValue) as? String ?? "unknown", l = dC.eGet(XMIAttribute.lowerBound.rawValue) as? Int ?? 0, u = dC.eGet(XMIAttribute.upperBound.rawValue) as? Int ?? 1
                    let typeName = await resolveTypeName(dC.eGet(XMIAttribute.eType.rawValue), in: resource)
                    if dC.eClass.name == EcoreClassifier.eAttribute.rawValue {
                        cls.eStructuralFeatures.append(EAttribute(id: dC.id, name: n, eType: EDataType(name: typeName), lowerBound: l, upperBound: u, defaultValueLiteral: dC.eGet(XMIAttribute.defaultValueLiteral.rawValue) as? String))
                    } else if dC.eClass.name == EcoreClassifier.eReference.rawValue {
                        var r = EReference(id: dC.id, name: n, eType: EClass(name: typeName), lowerBound: l, upperBound: u, containment: dC.eGet(XMIAttribute.containment.rawValue) as? Bool ?? false)
                        if let oId = (dC.eGet(XMIAttribute.eOpposite.rawValue) as? UUID) ?? (dC.eGet(XMIAttribute.opposite.rawValue) as? UUID) { r.opposite = oId }
                        cls.eStructuralFeatures.append(r)
                    }
                }
            }
        }
        let sIds = (d.eGet(XMIElement.eSuperTypes.rawValue) as? [UUID]) ?? (d.eGet(XMIElement.eSuperTypes.rawValue) as? UUID).map({ [$0] }) ?? []
        for id in sIds { if let sO = await resource.getObject(id), let sC = await resolveClass(sO, in: resource) { cls.eSuperTypes.append(sC) } }
        classCache[d.id] = cls
        return cls
    }

    private func resolveTypeName(_ typeObj: Any?, in resource: Resource) async -> String {
        if let id = typeObj as? UUID {
            if let obj = await resource.getObject(id) {
                if let d = obj as? DynamicEObject { return d.eGet(XMIAttribute.name.rawValue) as? String ?? "EObject" }
                if let n = obj as? any ENamedElement { return n.name }
            }
        }
        return "EObject"
    }

    private func resolveClassifier(_ obj: any EObject, in resource: Resource) async -> (any EClassifier)? {
        if let c = obj as? any EClassifier { return c }
        if let e = await resolveEnum(obj, in: resource) { return e }
        return await resolveClass(obj, in: resource)
    }

    private func generateSwiftPackage(from pkg: EPackage, in resource: Resource, referenceMap: [UUID: EReference]) async -> String {
        var res = "\n// Package: \(pkg.name)"
        for c in pkg.eClassifiers {
            if let cls = c as? EClass { res += await generateSwiftClass(from: cls, in: resource, referenceMap: referenceMap) }
            else if let enm = c as? EEnum { res += generateSwiftEnum(from: enm) }
            else if let o = c as? any EObject {
                if let rc = await resolveClass(o, in: resource) { res += await generateSwiftClass(from: rc, in: resource, referenceMap: referenceMap) }
                else if let re = await resolveEnum(o, in: resource) { res += generateSwiftEnum(from: re) }
            }
        }
        return res
    }

    private func generateSwiftEnum(from enm: EEnum) -> String {
        var res = "\n\nenum \(enm.name): Int, Sendable, Codable, CaseIterable {"
        for l in enm.literals { res += "\n    case \(l.name) = \(l.value)" }
        res += "\n}\n"
        return res
    }

    private func generateSwiftClass(from cls: EClass, in resource: Resource, referenceMap: [UUID: EReference]) async -> String {
        let kw = cls.isAbstract || cls.isInterface ? "protocol" : "class"
        var res = ""
        if kw == "protocol" {
            res += "\n\nprotocol \(cls.name): EObject {"
            for f in cls.eStructuralFeatures {
                if let a = f as? EAttribute { res += "\n    var \(a.name): \(swiftPropertyType(for: a)) { get set }" }
                else if let r = f as? EReference { res += "\n    var \(r.name): \(swiftPropertyType(for: r)) { get set }" }
            }
        } else {
            var parents = ["EObject", "Hashable"]
            if let first = cls.eSuperTypes.first(where: { !$0.isAbstract && !$0.isInterface }) { parents[0] = first.name }
            for s in cls.eSuperTypes.filter({ $0.isAbstract || $0.isInterface }) { parents.append(s.name) }
            res += "\n\nclass \(cls.name): \(parents.joined(separator: ", ")) {"
            if !cls.eSuperTypes.contains(where: { !$0.isAbstract && !$0.isInterface }) {
                res += "\n    let id: UUID = UUID()\n    let eClass: EClass"
            }
            var inherited = Set<String>()
            for s in cls.eSuperTypes { for f in s.eStructuralFeatures { inherited.insert(f.name) } }
            for f in cls.eStructuralFeatures.filter({ !inherited.contains($0.name) }) {
                if let a = f as? EAttribute { res += "\n    \(generateSwiftProperty(for: a))" }
                else if let r = f as? EReference { res += "\n    \(generateSwiftProperty(for: r, referenceMap: referenceMap))" }
            }
            res += "\n\n    init(eClass: EClass) {"
            if cls.eSuperTypes.contains(where: { !$0.isAbstract && !$0.isInterface }) { res += "\n        super.init(eClass: eClass)" }
            else { res += "\n        self.eClass = eClass" }
            res += "\n    }\n"

            res += "\n    static func == (lhs: \(cls.name), rhs: \(cls.name)) -> Bool { lhs.id == rhs.id }"
            res += "\n    func hash(into hasher: inout Hasher) { hasher.combine(id) }\n"

            res += "\n    func eGet(_ feature: some EStructuralFeature) -> (any EcoreValue)? {"
            res += "\n        switch feature.name {"
            for f in cls.allStructuralFeatures { res += "\n        case \"\(f.name)\": return \(f.name)" }
            res += "\n        default: return nil"
            res += "\n        }\n    }"

            res += "\n\n    func eSet(_ feature: some EStructuralFeature, value: (any EcoreValue)?) {"
            res += "\n        switch feature.name {"
            for f in cls.allStructuralFeatures {
                let type = swiftBaseType(for: f)
                let isMulti = isMultiValued(f)
                res += "\n        case \"\(f.name)\": if let v = value as? \(isMulti ? "[\(type)]" : type) { \(f.name) = v }"
            }
            res += "\n        default: break"
            res += "\n        }\n    }"
        }
        res += "\n}\n"
        return res
    }

    private func isMultiValued(_ f: any EStructuralFeature) -> Bool {
        if let a = f as? EAttribute { return a.upperBound == -1 || a.upperBound > 1 }
        if let r = f as? EReference { return r.upperBound == -1 || r.upperBound > 1 }
        return false
    }

    private func swiftBaseType(for f: any EStructuralFeature) -> String {
        if let a = f as? EAttribute { return mapEcoreType(a.eType.name) }
        if let r = f as? EReference { return r.eType.name }
        return "EObject"
    }

    private func swiftPropertyType(for f: any EStructuralFeature) -> String {
        let base = swiftBaseType(for: f), isMulti = isMultiValued(f)
        return isMulti ? "[\(base)]" : "\(base)?"
    }

    private func mapEcoreType(_ name: String) -> String {
        switch name {
        case "EString": return "String"
        case "EInt", "EIntegerObject": return "Int"
        case "EBoolean", "EBooleanObject": return "Bool"
        case "EDouble", "EDoubleObject": return "Double"
        case "EFloat", "EFloatObject": return "Float"
        case "ELong", "ELongObject": return "Int64"
        case "EShort", "EShortObject": return "Int16"
        case "EByte", "EByteObject": return "Int8"
        default: return name
        }
    }

    private func generateSwiftFactory(from pkg: EPackage) -> String {
        let name = "\(pkg.name.capitalized)Factory"
        var res = "\n\nstruct \(name) {"
        let concretes = pkg.eClassifiers.compactMap { $0 as? EClass }.filter { !$0.isAbstract && !$0.isInterface }
        for c in concretes { res += "\n    func create\(c.name)() -> \(c.name) { return \(c.name)(eClass: \(pkg.name.capitalized)Package.shared.e\(c.name)) }" }
        res += "\n\n    func create(_ eClass: EClass) -> any EObject {"
        res += "\n        switch eClass.id {"
        for c in concretes { res += "\n        case \(pkg.name.capitalized)Package.shared.e\(c.name).id: return create\(c.name)()" }
        res += "\n        default: fatalError(\"Unknown EClass: \\(eClass.name)\")"
        res += "\n        }\n    }\n}"
        return res
    }

    private func generateSwiftPackageDescriptor(from pkg: EPackage) -> String {
        let name = "\(pkg.name.capitalized)Package"
        var res = "\n\nstruct \(name) {"
        res += "\n    static let shared = \(name)()"
        res += "\n    let ePackage: EPackage"
        res += "\n    let factory = \(pkg.name.capitalized)Factory()"
        let classes = pkg.eClassifiers.compactMap { $0 as? EClass }
        for c in classes { res += "\n    let e\(c.name): EClass" }
        res += "\n\n    private init() {"
        res += "\n        ePackage = EPackage(name: \"\(pkg.name)\")"
        for c in classes {
            res += "\n        e\(c.name) = EClass(name: \"\(c.name)\", isAbstract: \(c.isAbstract), isInterface: \(c.isInterface))"
            res += "\n        var p = ePackage; p.eClassifiers.append(e\(c.name))"
        }
        res += "\n    }\n}\n"
        return res
    }

    private func generateSwiftProperty(for a: EAttribute) -> String {
        let type = mapEcoreType(a.eType.name), isMulti = a.upperBound == -1 || a.upperBound > 1
        let base = "var \(a.name): \(isMulti ? "[\(type)]" : "\(type)?")"
        if let def = a.defaultValueLiteral { return "\(base) = \(formatDefaultValue(def, for: type))" }
        return isMulti ? "\(base) = []" : base
    }

    private func generateSwiftProperty(for r: EReference, referenceMap: [UUID: EReference], isProtocol: Bool = false) -> String {
        let name = r.name, isMulti = r.upperBound == -1 || r.upperBound > 1, type = r.eType.name
        let opposite = r.opposite.flatMap { referenceMap[$0] }
        if isProtocol { return "var \(name): \(isMulti ? "[\(type)]" : "\(type)?")" }
        var res = ""
        if let opp = opposite {
            res += "/// Bidirectional reference to \(type) (opposite: \(opp.name))\n    "
            if isMulti { res += "var \(name): [\(type)] = []" }
            else {
                let strength = r.containment ? "" : "weak "
                let oppName = opp.name, oppIsMulti = opp.upperBound == -1 || opp.upperBound > 1
                res += "\(strength)var \(name): \(type)? {\n        didSet {\n"
                if oppIsMulti {
                    res += "            if let old = oldValue, let index = old.\(oppName).firstIndex(where: { $0 === self }) { old.\(oppName).remove(at: index) }\n"
                    res += "            if let new = \(name), !new.\(oppName).contains(where: { $0 === self }) { new.\(oppName).append(self) }\n"
                } else {
                    res += "            if let old = oldValue, old.\(oppName) === self { old.\(oppName) = nil }\n"
                    res += "            if let new = \(name), new.\(oppName) !== self { new.\(oppName) = self }\n"
                }
                res += "        }\n    }"
            }
        } else {
            let strength = (r.containment || isMulti) ? "" : "weak "
            res += "\(strength)var \(name): \(isMulti ? "[\(type)] = []" : "\(type)?")"
        }
        return res
    }

    private func formatDefaultValue(_ literal: String, for typeName: String) -> String {
        switch typeName {
        case "String": return "\"\(literal)\""
        case "Bool": return literal.lowercased()
        case "Int", "Int8", "Int16", "Int64", "Double", "Float", "Decimal": return literal
        case "Character": return "\"\(literal.prefix(1))\""
        default: return ".\(literal)"
        }
    }

    private func generateCpp(from resource: Resource, verbose: Bool) async throws {
        let objects = await resource.getRootObjects()
        let headerFile = outputDirectory.appendingPathComponent("Generated.hpp")
        var headerContent = "#pragma once\n#include <string>\n#include <vector>\n"
        for obj in objects {
            if let cls = await resolveClass(obj, in: resource) {
                headerContent += "\nclass \(cls.name) {\npublic:\n"
                for f in cls.eStructuralFeatures { if let a = f as? EAttribute { headerContent += "    std::string get\(a.name.capitalized)() const;\n"; headerContent += "    void set\(a.name.capitalized)(std::string v);\n" } }
                headerContent += "};\n"
            }
        }
        try headerContent.write(to: headerFile, atomically: true, encoding: .utf8)
    }
}
