//
// CodeGenerator.swift
// swift-ecore
//
//  Created by Rene Hexel on 3/12/2025.
//  Copyright Â© 2025 Rene Hexel. All rights reserved.
//
import ECore
import Foundation

actor CodeGenerator {
    let language: String
    let outputDirectory: URL
    private var classCache: [UUID: EClass] = [:]

    init(language: String, outputDirectory: URL) throws {
        guard ["swift", "cpp", "c", "llvm"].contains(language) else { throw GenerationError.unsupportedLanguage(language) }
        self.language = language
        self.outputDirectory = outputDirectory
    }

    func generate(from resource: Resource, verbose: Bool) async throws {
        if language == "swift" { try await generateSwift(from: resource, verbose: verbose) }
        else if language == "cpp" { try await generateCpp(from: resource, verbose: verbose) }
    }

    private func generateSwift(from resource: Resource, verbose: Bool) async throws {
        let objects = await resource.getRootObjects()
        classCache.removeAll()
        let referenceMap = await buildReferenceMap(from: objects, in: resource)
        let outputFile = outputDirectory.appendingPathComponent("Generated.swift")
        var content = "// Generated by Swift Ecore\nimport Foundation\nimport ECore\n"

        for obj in objects {
            if let pkg = await resolvePackage(obj, in: resource) {
                content += await generateSwiftPackage(from: pkg, in: resource, referenceMap: referenceMap)
            } else if let cls = await resolveClass(obj, in: resource) {
                content += await generateSwiftClass(from: cls, in: resource, referenceMap: referenceMap)
            }
        }
        try content.write(to: outputFile, atomically: true, encoding: .utf8)
    }

    private func buildReferenceMap(from objects: [any EObject], in resource: Resource) async -> [UUID: EReference] {
        var map: [UUID: EReference] = [:]
        for obj in objects {
            if let cls = await resolveClass(obj, in: resource) {
                for f in cls.eStructuralFeatures { if let r = f as? EReference { map[r.id] = r } }
            } else if let pkg = await resolvePackage(obj, in: resource) {
                for c in pkg.eClassifiers {
                    if let cO = c as? any EObject, let cC = await resolveClass(cO, in: resource) {
                        for f in cC.eStructuralFeatures { if let r = f as? EReference { map[r.id] = r } }
                    }
                }
            }
        }
        return map
    }

    private func resolvePackage(_ obj: any EObject, in resource: Resource) async -> EPackage? {
        if let p = obj as? EPackage { return p }
        guard let d = obj as? DynamicEObject, d.eClass.name == "EPackage" || d.eClass.name == "EResource" else { return nil }
        var pkg = EPackage(id: d.id, name: d.eGet("name") as? String ?? "Unknown")
        if let ids = d.eGet("eClassifiers") as? [UUID] {
            for id in ids { if let child = await resource.getObject(id), let c = await resolveClassifier(child, in: resource) { pkg.eClassifiers.append(c) } }
        }
        return pkg
    }

    private func resolveClass(_ obj: any EObject, in resource: Resource) async -> EClass? {
        if let c = obj as? EClass { return c }
        if let cached = classCache[obj.id] { return cached }
        guard let d = obj as? DynamicEObject, d.eClass.name == "EClass" else { return nil }
        var cls = EClass(id: d.id, name: d.eGet("name") as? String ?? "Unknown", isAbstract: d.eGet("abstract") as? Bool ?? false, isInterface: d.eGet("interface") as? Bool ?? false)
        classCache[d.id] = cls
        if let ids = d.eGet("eStructuralFeatures") as? [UUID] {
            for id in ids {
                if let child = await resource.getObject(id), let dC = child as? DynamicEObject {
                    let n = dC.eGet("name") as? String ?? "unknown", l = dC.eGet("lowerBound") as? Int ?? 0, u = dC.eGet("upperBound") as? Int ?? 1
                    if dC.eClass.name == "EAttribute" {
                        cls.eStructuralFeatures.append(EAttribute(id: dC.id, name: n, eType: EDataType(name: "EString"), lowerBound: l, upperBound: u))
                    } else if dC.eClass.name == "EReference" {
                        var r = EReference(id: dC.id, name: n, eType: EClass(name: "EObject"), lowerBound: l, upperBound: u, containment: dC.eGet("containment") as? Bool ?? false)
                        if let oId = (dC.eGet("eOpposite") as? UUID) ?? (dC.eGet("opposite") as? UUID) { r.opposite = oId }
                        cls.eStructuralFeatures.append(r)
                    }
                }
            }
        }
        let sIds = (d.eGet("eSuperTypes") as? [UUID]) ?? (d.eGet("eSuperTypes") as? UUID).map({ [$0] }) ?? []
        for id in sIds { if let sO = await resource.getObject(id), let sC = await resolveClass(sO, in: resource) { cls.eSuperTypes.append(sC) } }
        classCache[d.id] = cls
        return cls
    }

    private func resolveClassifier(_ obj: any EObject, in resource: Resource) async -> (any EClassifier)? {
        if let c = obj as? any EClassifier { return c }
        return await resolveClass(obj, in: resource)
    }

    private func generateSwiftPackage(from pkg: EPackage, in resource: Resource, referenceMap: [UUID: EReference]) async -> String {
        var res = "\n// Package: \(pkg.name)"
        for c in pkg.eClassifiers {
            if let cls = c as? EClass { res += await generateSwiftClass(from: cls, in: resource, referenceMap: referenceMap) }
            else if let o = c as? any EObject, let rc = await resolveClass(o, in: resource) { res += await generateSwiftClass(from: rc, in: resource, referenceMap: referenceMap) }
        }
        return res
    }

    private func generateSwiftClass(from cls: EClass, in resource: Resource, referenceMap: [UUID: EReference]) async -> String {
        let kw = cls.isAbstract || cls.isInterface ? "protocol" : "class"
        var res = ""
        if kw == "protocol" {
            res += "\n\nprotocol \(cls.name): EObject {"
            for f in cls.eStructuralFeatures {
                if let a = f as? EAttribute { res += "\n    var \(a.name): \(a.upperBound == -1 || a.upperBound > 1 ? "[String]" : "String?") { get set }" }
                else if let r = f as? EReference { res += "\n    var \(r.name): \(r.upperBound == -1 || r.upperBound > 1 ? "[\(r.eType.name)]" : "\(r.eType.name)?") { get set }" }
            }
        } else {
            var parents = ["EObject"]
            if let first = cls.eSuperTypes.first(where: { !$0.isAbstract && !$0.isInterface }) { parents[0] = first.name }
            for s in cls.eSuperTypes.filter({ $0.isAbstract || $0.isInterface }) { parents.append(s.name) }
            res += "\n\nclass \(cls.name): \(parents.joined(separator: ", ")) {"
            if !cls.eSuperTypes.contains(where: { !$0.isAbstract && !$0.isInterface }) { res += "\n    let id: UUID = UUID()\n    let eClass: EClass" }
            var inherited = Set<String>()
            for s in cls.eSuperTypes { for f in s.eStructuralFeatures { inherited.insert(f.name) } }
            for f in cls.eStructuralFeatures.filter({ !inherited.contains($0.name) }) {
                if let a = f as? EAttribute { res += "\n    \(generateSwiftProperty(for: a))" }
                else if let r = f as? EReference { res += "\n    \(generateSwiftProperty(for: r, referenceMap: referenceMap))" }
            }
            res += "\n\n    init(eClass: EClass) {"
            if cls.eSuperTypes.contains(where: { !$0.isAbstract && !$0.isInterface }) { res += "\n        super.init(eClass: eClass)" }
            else { res += "\n        self.eClass = eClass" }
            res += "\n    }\n"
        }
        res += "\n}\n"
        return res
    }

    private func generateSwiftProperty(for a: EAttribute) -> String {
        let isMulti = a.upperBound == -1 || a.upperBound > 1
        return "var \(a.name): \(isMulti ? "[String] = []" : "String?")"
    }

    private func generateSwiftProperty(for r: EReference, referenceMap: [UUID: EReference], isProtocol: Bool = false) -> String {
        let name = r.name, isMulti = r.upperBound == -1 || r.upperBound > 1, type = r.eType.name
        let opposite = r.opposite.flatMap { referenceMap[$0] }
        if isProtocol { return "var \(name): \(isMulti ? "[\(type)]" : "\(type)?")" }
        var res = ""
        if let opp = opposite {
            res += "/// Bidirectional reference to \(type) (opposite: \(opp.name))\n    "
            if isMulti { res += "var \(name): [\(type)] = []" }
            else {
                let strength = r.containment ? "" : "weak "
                let oppName = opp.name, oppIsMulti = opp.upperBound == -1 || opp.upperBound > 1
                res += "\(strength)var \(name): \(type)? {\n        didSet {\n"
                if oppIsMulti {
                    res += "            if let old = oldValue, let index = old.\(oppName).firstIndex(where: { $0 === self }) { old.\(oppName).remove(at: index) }\n"
                    res += "            if let new = \(name), !new.\(oppName).contains(where: { $0 === self }) { new.\(oppName).append(self) }\n"
                } else {
                    res += "            if let old = oldValue, old.\(oppName) === self { old.\(oppName) = nil }\n"
                    res += "            if let new = \(name), new.\(oppName) !== self { new.\(oppName) = self }\n"
                }
                res += "        }\n    }"
            }
        } else {
            let strength = (r.containment || isMulti) ? "" : "weak "
            res += "\(strength)var \(name): \(isMulti ? "[\(type)] = []" : "\(type)?")"
        }
        return res
    }

    private func generateCpp(from resource: Resource, verbose: Bool) async throws {
        let objects = await resource.getRootObjects()
        let headerFile = outputDirectory.appendingPathComponent("Generated.hpp")
        var headerContent = "#pragma once\n#include <string>\n#include <vector>\n"
        for obj in objects {
            if let cls = await resolveClass(obj, in: resource) {
                headerContent += "\nclass \(cls.name) {\npublic:\n"
                for f in cls.eStructuralFeatures { if let a = f as? EAttribute { headerContent += "    std::string get\(a.name.capitalized)() const;\n"; headerContent += "    void set\(a.name.capitalized)(std::string v);\n" } }
                headerContent += "};\n"
            }
        }
        try headerContent.write(to: headerFile, atomically: true, encoding: .utf8)
    }
}