//
// CodeGenerator.swift
// swift-ecore
//
//  Created by Rene Hexel on 3/12/2025.
//  Copyright © 2025 Rene Hexel. All rights reserved.
//
import ECore
import Foundation

// MARK: - Code Generator

/// Actor responsible for generating code from models in various target languages.
///
/// The code generator supports multiple target languages including Swift, C++, C, and LLVM IR.
/// It processes model objects and generates appropriate source code structures.
actor CodeGenerator {
    /// The target language for code generation.
    let language: String

    /// The output directory where generated files will be written.
    let outputDirectory: URL

    /// Initialises a new code generator.
    ///
    /// - Parameters:
    ///   - language: The target language (must be one of: swift, cpp, c, llvm).
    ///   - outputDirectory: The directory where generated files will be written.
    /// - Throws: `GenerationError.unsupportedLanguage` if the language is not supported.
    init(language: String, outputDirectory: URL) throws {
        guard ["swift", "cpp", "c", "llvm"].contains(language) else {
            throw GenerationError.unsupportedLanguage(language)
        }
        self.language = language
        self.outputDirectory = outputDirectory
    }

    /// Generates code from the provided resource.
    ///
    /// - Parameters:
    ///   - resource: The resource containing model objects to generate from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: `GenerationError` if generation fails.
    func generate(from resource: Resource, verbose: Bool) async throws {
        let objects = await resource.getRootObjects()

        if objects.isEmpty {
            if verbose { print("No objects found in model") }
            return
        }

        switch language {
        case "swift":
            try await generateSwift(from: objects, verbose: verbose)
        case "cpp":
            try await generateCpp(from: objects, verbose: verbose)
        case "c":
            try await generateC(from: objects, verbose: verbose)
        case "llvm":
            try await generateLLVM(from: objects, verbose: verbose)
        default:
            throw GenerationError.unsupportedLanguage(language)
        }
    }

    /// Generates Swift code from the provided objects.
    ///
    /// - Parameters:
    ///   - objects: The model objects to generate code from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: File I/O errors if writing fails.
    private func generateSwift(from objects: [any EObject], verbose: Bool) async throws {
        if verbose { print("Generating Swift code...") }

        let outputFile = outputDirectory.appendingPathComponent("Generated.swift")
        var content = """
            //
            // Generated.swift
            // Generated by Swift Ecore
            //
            import Foundation
            import ECore

            """

        for obj in objects {
            if let eClass = obj as? EClass {
                content += generateSwiftClass(from: eClass)
            } else if let ePackage = obj as? EPackage {
                content += generateSwiftPackage(from: ePackage)
            }
        }

        try content.write(to: outputFile, atomically: true, encoding: .utf8)
        if verbose { print("Generated: \(outputFile.path)") }
    }

    /// Generates C++ code from the provided objects.
    ///
    /// - Parameters:
    ///   - objects: The model objects to generate code from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: File I/O errors if writing fails.
    private func generateCpp(from objects: [any EObject], verbose: Bool) async throws {
        if verbose { print("Generating C++ code...") }

        // Header file
        let headerFile = outputDirectory.appendingPathComponent("Generated.hpp")
        var headerContent = """
            //
            // Generated.hpp
            // Generated by Swift Ecore
            //
            #pragma once
            #include <memory>
            #include <string>
            #include <vector>

            """

        // Implementation file
        let implFile = outputDirectory.appendingPathComponent("Generated.cpp")
        var implContent = """
            //
            // Generated.cpp
            // Generated by Swift Ecore
            //
            #include "Generated.hpp"

            """

        for obj in objects {
            if let eClass = obj as? EClass {
                headerContent += generateCppClassHeader(from: eClass)
                implContent += generateCppClassImpl(from: eClass)
            }
        }

        try headerContent.write(to: headerFile, atomically: true, encoding: .utf8)
        try implContent.write(to: implFile, atomically: true, encoding: .utf8)

        if verbose {
            print("Generated: \(headerFile.path)")
            print("Generated: \(implFile.path)")
        }
    }

    /// Generates C code from the provided objects.
    ///
    /// - Parameters:
    ///   - objects: The model objects to generate code from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: File I/O errors if writing fails.
    private func generateC(from objects: [any EObject], verbose: Bool) async throws {
        if verbose { print("Generating C code...") }

        let headerFile = outputDirectory.appendingPathComponent("generated.h")
        let implFile = outputDirectory.appendingPathComponent("generated.c")

        var headerContent = """
            /*
             * generated.h
             * Generated by Swift Ecore
             */
            #ifndef GENERATED_H
            #define GENERATED_H

            """

        let implContent = """
            /*
             * generated.c
             * Generated by Swift Ecore
             */
            #include "generated.h"

            """

        headerContent += "\n#endif /* GENERATED_H */"

        try headerContent.write(to: headerFile, atomically: true, encoding: .utf8)
        try implContent.write(to: implFile, atomically: true, encoding: .utf8)

        if verbose {
            print("Generated: \(headerFile.path)")
            print("Generated: \(implFile.path)")
        }
    }

    /// Generates LLVM IR from the provided objects.
    ///
    /// - Parameters:
    ///   - objects: The model objects to generate code from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: File I/O errors if writing fails.
    private func generateLLVM(from objects: [any EObject], verbose: Bool) async throws {
        if verbose { print("Generating LLVM IR...") }

        let outputFile = outputDirectory.appendingPathComponent("generated.ll")
        let content = """
            ; generated.ll
            ; Generated by Swift Ecore

            """

        try content.write(to: outputFile, atomically: true, encoding: .utf8)
        if verbose { print("Generated: \(outputFile.path)") }
    }

    // MARK: - Swift Generation Helpers

    /// Determines the appropriate Swift type declaration for an EClass.
    ///
    /// - Parameter eClass: The EClass to analyze.
    /// - Returns: The type keyword ("class", "struct", or "protocol").
    private func swiftTypeKeyword(for eClass: EClass) -> String {
        // Abstract or interface EClasses → protocols
        if eClass.isAbstract || eClass.isInterface {
            return "protocol"
        }

        // Has references or inheritance → class (needs reference semantics)
        let hasReferences = eClass.eStructuralFeatures.contains { $0 is EReference }
        let hasInheritance = !eClass.eSuperTypes.isEmpty

        if hasReferences || hasInheritance {
            return "class"
        }

        // Pure data attributes only → struct (value semantics acceptable)
        return "struct"
    }

    /// Gets the concrete (non-abstract) supertypes of an EClass.
    ///
    /// - Parameter eClass: The EClass to analyze.
    /// - Returns: Array of concrete supertypes.
    private func getConcreteSuperTypes(for eClass: EClass) -> [EClass] {
        return eClass.eSuperTypes.filter { !$0.isAbstract && !$0.isInterface }
    }

    /// Gets the abstract/interface supertypes of an EClass.
    ///
    /// - Parameter eClass: The EClass to analyze.
    /// - Returns: Array of abstract supertypes.
    private func getAbstractSuperTypes(for eClass: EClass) -> [EClass] {
        return eClass.eSuperTypes.filter { $0.isAbstract || $0.isInterface }
    }

    /// Builds the inheritance/conformance list for a Swift type declaration.
    ///
    /// - Parameter eClass: The EClass to analyze.
    /// - Returns: String with superclass and protocol conformances, or "EObject" if none.
    private func buildInheritanceList(for eClass: EClass) -> String {
        var inheritanceList: [String] = []

        let concreteSuperTypes = getConcreteSuperTypes(for: eClass)
        let abstractSuperTypes = getAbstractSuperTypes(for: eClass)

        // Single concrete supertype → extend from it
        if let concreteSuperType = concreteSuperTypes.first {
            inheritanceList.append(concreteSuperType.name)
        } else {
            // No concrete supertype → conform to EObject
            inheritanceList.append("EObject")
        }

        // Add abstract supertypes as protocol conformances
        for abstractSuperType in abstractSuperTypes {
            inheritanceList.append(abstractSuperType.name)
        }

        return inheritanceList.joined(separator: ", ")
    }

    /// Gets locally-defined features (not inherited from supertypes).
    ///
    /// - Parameter eClass: The EClass to analyze.
    /// - Returns: Array of locally-defined structural features.
    private func getLocalFeatures(for eClass: EClass) -> [any EStructuralFeature] {
        // If no supertypes, all features are local
        if eClass.eSuperTypes.isEmpty {
            return eClass.eStructuralFeatures
        }

        // Collect all inherited feature names
        var inheritedFeatureNames = Set<String>()
        for superType in eClass.eSuperTypes {
            for feature in superType.eStructuralFeatures {
                inheritedFeatureNames.insert(feature.name)
            }
        }

        // Return only features not in supertypes
        return eClass.eStructuralFeatures.filter { !inheritedFeatureNames.contains($0.name) }
    }

    /// Generates documentation comments from EClass annotations.
    ///
    /// Extracts documentation from eAnnotations and formats it as Swift doc comments.
    ///
    /// - Parameter eClass: The EClass to extract documentation from.
    /// - Returns: Formatted Swift documentation comment string, or empty string if no documentation found.
    private func generateDocumentation(for eClass: EClass) -> String {
        return extractDocumentationFromAnnotations(eClass.eAnnotations)
    }

    /// Generates documentation comments from EStructuralFeature annotations.
    ///
    /// Extracts documentation from eAnnotations and formats it as Swift doc comments.
    ///
    /// - Parameter feature: The EStructuralFeature to extract documentation from.
    /// - Returns: Formatted Swift documentation comment string, or empty string if no documentation found.
    private func generateDocumentation(for feature: any EStructuralFeature) -> String {
        // Try to access annotations if available (cast to concrete types)
        if let attribute = feature as? EAttribute {
            return extractDocumentationFromAnnotations(attribute.eAnnotations)
        } else if let reference = feature as? EReference {
            return extractDocumentationFromAnnotations(reference.eAnnotations)
        }
        return ""
    }

    /// Helper to extract documentation from annotations.
    ///
    /// - Parameter annotations: The annotations to search.
    /// - Returns: Formatted Swift documentation comment string, or empty string if no documentation found.
    private func extractDocumentationFromAnnotations(_ annotations: [EAnnotation]) -> String {
        // Look for documentation in eAnnotations
        for annotation in annotations {
            // Common annotation sources for documentation
            if annotation.source == "http://www.eclipse.org/emf/2002/GenModel" ||
               annotation.source == "documentation" {
                // Try to get documentation from details
                for (key, value) in annotation.details {
                    if key == "documentation" || key == "body" {
                        // Format as Swift doc comment
                        let lines = value.split(separator: "\n")
                        if lines.count == 1 {
                            return "\n\n/// \(value)"
                        } else {
                            var result = "\n\n/**"
                            for line in lines {
                                result += "\n * \(line)"
                            }
                            result += "\n */"
                            return result
                        }
                    }
                }
            }
        }
        return ""
    }

    /// Generates a Swift type (class/struct/protocol) from an EClass.
    ///
    /// - Parameter eClass: The EClass to generate from.
    /// - Returns: Swift code as a string.
    private func generateSwiftClass(from eClass: EClass) -> String {
        let typeKeyword = swiftTypeKeyword(for: eClass)
        var result = ""

        // Generate documentation comment if available
        let documentation = generateDocumentation(for: eClass)
        if !documentation.isEmpty {
            result += documentation
        }

        // Generate type declaration
        if typeKeyword == "protocol" {
            // Protocol declaration for abstract/interface EClasses
            result += "\n\nprotocol \(eClass.name): EObject {"

            // Generate property requirements
            for feature in eClass.eStructuralFeatures {
                // Add documentation for the property if available
                let featureDoc = generateDocumentation(for: feature)
                if !featureDoc.isEmpty {
                    result += featureDoc
                }

                if let attribute = feature as? EAttribute {
                    let property = generateSwiftProperty(for: attribute)
                    result += "\n    \(property) { get set }"
                } else if let reference = feature as? EReference {
                    let property = generateSwiftProperty(for: reference)
                    result += "\n    \(property) { get set }"
                }
            }
        } else if typeKeyword == "class" {
            // Class declaration with inheritance/protocol conformance
            let inheritanceList = buildInheritanceList(for: eClass)
            result += "\n\nclass \(eClass.name): \(inheritanceList) {"

            // Only include id and eClass if not inherited from a concrete supertype
            let concreteSuperTypes = getConcreteSuperTypes(for: eClass)
            if concreteSuperTypes.isEmpty {
                result += "\n    let id: EUUID = EUUID()"
                result += "\n    let eClass: EClass"
            }

            // Generate only locally-defined properties (not inherited)
            let localFeatures = getLocalFeatures(for: eClass)
            for feature in localFeatures {
                // Add documentation for the property if available
                let featureDoc = generateDocumentation(for: feature)
                if !featureDoc.isEmpty {
                    result += featureDoc
                }

                if let attribute = feature as? EAttribute {
                    result += "\n    \(generateSwiftProperty(for: attribute))"
                } else if let reference = feature as? EReference {
                    result += "\n    \(generateSwiftProperty(for: reference))"
                }
            }

            // Generate initializers
            result += generateSwiftInitializers(for: eClass)
        } else {
            // Struct declaration
            result += "\n\nstruct \(eClass.name) {"

            // Generate properties with documentation
            for feature in eClass.eStructuralFeatures {
                // Add documentation for the property if available
                let featureDoc = generateDocumentation(for: feature)
                if !featureDoc.isEmpty {
                    result += featureDoc
                }

                if let attribute = feature as? EAttribute {
                    result += "\n    \(generateSwiftProperty(for: attribute))"
                } else if let reference = feature as? EReference {
                    result += "\n    \(generateSwiftProperty(for: reference))"
                }
            }
        }

        result += "\n}\n"
        return result
    }

    /// Generates Swift code from an EPackage.
    ///
    /// - Parameter ePackage: The EPackage to generate from.
    /// - Returns: Swift code as a string.
    private func generateSwiftPackage(from ePackage: EPackage) -> String {
        var result = """

            // Package: \(ePackage.name)
            """

        for classifier in ePackage.eClassifiers {
            if let eClass = classifier as? EClass {
                result += generateSwiftClass(from: eClass)
            }
        }

        return result
    }

    /// Maps an EDataType to a Swift type name.
    ///
    /// - Parameter dataType: The EDataType to map.
    /// - Returns: The corresponding Swift type name.
    private func swiftTypeName(for dataType: EDataType?) -> String {
        guard let dataType = dataType else { return "Any" }

        // Check instance class name first (for standard EMF types)
        if let instanceClassName = dataType.instanceClassName {
            switch instanceClassName {
            case "String", "Swift.String": return "String"
            case "Int", "Swift.Int": return "Int"
            case "Bool", "Swift.Bool": return "Bool"
            case "Double", "Swift.Double": return "Double"
            case "Float", "Swift.Float": return "Float"
            default: break
            }
        }

        // Map by EDataType name (standard Ecore types)
        switch dataType.name {
        case "EString": return "String"
        case "EInt": return "Int"
        case "EBoolean": return "Bool"
        case "EDouble": return "Double"
        case "EFloat": return "Float"
        case "EByte": return "Int8"
        case "EShort": return "Int16"
        case "ELong": return "Int64"
        case "EChar": return "Character"
        case "EDate": return "Date"
        case "EBigInteger": return "BigInt"
        case "EBigDecimal": return "Decimal"
        default: return dataType.name
        }
    }

    /// Generates a Swift property declaration for an attribute.
    ///
    /// - Parameter attribute: The EAttribute to generate a property for.
    /// - Returns: Swift property declaration.
    private func generateSwiftProperty(for attribute: EAttribute) -> String {
        let typeName = swiftTypeName(for: attribute.eType as? EDataType)
        let isRequired = attribute.lowerBound >= 1
        let isMultiValued = attribute.upperBound == -1 || attribute.upperBound > 1

        if isMultiValued {
            // Multi-valued attribute → array
            return "var \(attribute.name): [\(typeName)] = []"
        } else if isRequired {
            // Required single-valued → non-optional with default or fatalError in init
            if let defaultValue = attribute.defaultValueLiteral {
                return "var \(attribute.name): \(typeName) = \(formatDefaultValue(defaultValue, for: typeName))"
            } else {
                // Will require initialization in init method
                return "var \(attribute.name): \(typeName)"
            }
        } else {
            // Optional single-valued → optional type
            if let defaultValue = attribute.defaultValueLiteral {
                return "var \(attribute.name): \(typeName)? = \(formatDefaultValue(defaultValue, for: typeName))"
            } else {
                return "var \(attribute.name): \(typeName)?"
            }
        }
    }

    /// Generates a Swift property declaration for a reference.
    ///
    /// - Parameter reference: The EReference to generate a property for.
    /// - Returns: Swift property declaration.
    private func generateSwiftProperty(for reference: EReference) -> String {
        let typeName = reference.eType.name
        let isMultiValued = reference.upperBound == -1 || reference.upperBound > 1
        let isContainment = reference.containment
        let hasOpposite = reference.opposite != nil

        // Add comment for bidirectional references
        var result = ""
        if hasOpposite {
            result += " // Bidirectional reference (has opposite)"
        }

        if isMultiValued {
            // Multi-valued reference → array
            if hasOpposite {
                result += "\n    // TODO: Implement bidirectional update logic for array modifications"
            }
            result += "\n    var \(reference.name): [\(typeName)] = []"
        } else {
            // Single-valued reference
            if hasOpposite {
                result += "\n    // TODO: Implement didSet to update opposite reference"
            }
            // Containment references are strong, non-containment are weak
            if isContainment {
                // Containment: strong reference (parent owns child)
                result += "\n    var \(reference.name): \(typeName)?"
            } else {
                // Non-containment: weak reference (avoid retain cycles)
                // Note: weak references must be optional in Swift
                result += "\n    weak var \(reference.name): \(typeName)?"
            }
        }

        return result.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    /// Formats a default value literal for Swift code.
    ///
    /// - Parameters:
    ///   - literal: The default value literal from the metamodel.
    ///   - typeName: The Swift type name.
    /// - Returns: Formatted Swift literal.
    private func formatDefaultValue(_ literal: String, for typeName: String) -> String {
        switch typeName {
        case "String":
            return "\"\(literal)\""
        case "Bool":
            return literal.lowercased()
        case "Int", "Int8", "Int16", "Int64", "Double", "Float", "Decimal":
            return literal
        case "Character":
            return "\"\(literal.prefix(1))\""
        default:
            return literal
        }
    }

    /// Generates Swift initializers for a class.
    ///
    /// - Parameter eClass: The EClass to generate initializers for.
    /// - Returns: Swift initializer code.
    private func generateSwiftInitializers(for eClass: EClass) -> String {
        var result = ""

        // Check if this class has a concrete supertype
        let concreteSuperTypes = getConcreteSuperTypes(for: eClass)
        let hasConcreteSuperType = !concreteSuperTypes.isEmpty

        // Get locally-defined features only
        let localFeatures = getLocalFeatures(for: eClass)

        // Collect required attributes from local features
        var requiredParams: [(name: String, type: String)] = []

        for feature in localFeatures {
            if let attribute = feature as? EAttribute {
                let isRequired = attribute.lowerBound >= 1
                let hasDefault = attribute.defaultValueLiteral != nil
                let isMultiValued = attribute.upperBound == -1 || attribute.upperBound > 1

                if isRequired && !hasDefault && !isMultiValued {
                    let typeName = swiftTypeName(for: attribute.eType as? EDataType)
                    requiredParams.append((name: attribute.name, type: typeName))
                }
            }
        }

        // Designated initializer: init(eClass:)
        result += "\n\n    init(eClass: EClass) {"
        if hasConcreteSuperType {
            // Call superclass initializer
            result += "\n        super.init(eClass: eClass)"
        } else {
            // Initialize eClass property
            result += "\n        self.eClass = eClass"
        }
        // Note: Required properties without defaults will need to be set manually or have fatalError
        for param in requiredParams {
            result += "\n        // TODO: Initialize required property '\(param.name)'"
        }
        result += "\n    }"

        // Convenience initializer with all properties (if there are any settable properties)
        // Use only local features (not inherited)
        let settableFeatures = localFeatures.filter { feature in
            if let attribute = feature as? EAttribute {
                let isMultiValued = attribute.upperBound == -1 || attribute.upperBound > 1
                return !isMultiValued
            }
            return feature is EReference
        }

        if !settableFeatures.isEmpty {
            result += "\n\n    convenience init(eClass: EClass"

            // Add parameters for each settable feature
            for feature in settableFeatures {
                if let attribute = feature as? EAttribute {
                    let typeName = swiftTypeName(for: attribute.eType as? EDataType)
                    let isRequired = attribute.lowerBound >= 1 && attribute.defaultValueLiteral == nil

                    if isRequired {
                        result += ", \(attribute.name): \(typeName)"
                    } else {
                        result += ", \(attribute.name): \(typeName)? = nil"
                    }
                } else if let reference = feature as? EReference {
                    let typeName = reference.eType.name
                    let isMultiValued = reference.upperBound == -1 || reference.upperBound > 1

                    if !isMultiValued {
                        result += ", \(reference.name): \(typeName)? = nil"
                    }
                }
            }

            result += ") {"
            result += "\n        self.init(eClass: eClass)"

            // Set properties
            for feature in settableFeatures {
                if let attribute = feature as? EAttribute {
                    result += "\n        self.\(attribute.name) = \(attribute.name)"
                } else if let reference = feature as? EReference {
                    let isMultiValued = reference.upperBound == -1 || reference.upperBound > 1
                    if !isMultiValued {
                        result += "\n        self.\(reference.name) = \(reference.name)"
                    }
                }
            }

            result += "\n    }"
        }

        return result
    }

    // MARK: - C++ Generation Helpers

    /// Generates a C++ class header from an EClass.
    ///
    /// - Parameter eClass: The EClass to generate from.
    /// - Returns: C++ header code as a string.
    private func generateCppClassHeader(from eClass: EClass) -> String {
        var result = """

            class \(eClass.name) {
            public:
            """

        for feature in eClass.eStructuralFeatures {
            if let attribute = feature as? EAttribute {
                let typeName = cppTypeName(for: attribute.eType as? EDataType)
                result +=
                    "\n    \(typeName) get\(attribute.name.capitalized)() const;"
                result +=
                    "\n    void set\(attribute.name.capitalized)(const \(typeName)& value);"
            }
        }

        result += """

            private:
            """

        for feature in eClass.eStructuralFeatures {
            if let attribute = feature as? EAttribute {
                let typeName = cppTypeName(for: attribute.eType as? EDataType)
                result += "\n    \(typeName) \(attribute.name)_;"
            }
        }

        result += "\n};\n"
        return result
    }

    /// Generates C++ class implementation from an EClass.
    ///
    /// - Parameter eClass: The EClass to generate from.
    /// - Returns: C++ implementation code as a string.
    private func generateCppClassImpl(from eClass: EClass) -> String {
        var result = ""

        for feature in eClass.eStructuralFeatures {
            if let attribute = feature as? EAttribute {
                let className = eClass.name
                let attrName = attribute.name
                let typeName = cppTypeName(for: attribute.eType as? EDataType)

                result += """

                    \(typeName) \(className)::get\(attrName.capitalized)() const {
                        return \(attrName)_;
                    }

                    void \(className)::set\(attrName.capitalized)(const \(typeName)& value) {
                        \(attrName)_ = value;
                    }
                    """
            }
        }

        return result
    }

    /// Maps an EDataType to a C++ type name.
    ///
    /// - Parameter dataType: The EDataType to map.
    /// - Returns: The corresponding C++ type name.
    private func cppTypeName(for dataType: EDataType?) -> String {
        guard let dataType = dataType else { return "void*" }

        switch dataType.instanceClassName {
        case "String": return "std::string"
        case "Int": return "int"
        case "Bool": return "bool"
        case "Double": return "double"
        case "Float": return "float"
        default: return dataType.name
        }
    }
}
