//
// CodeGenerator.swift
// swift-ecore
//
//  Created by Rene Hexel on 3/12/2025.
//  Copyright Â© 2025 Rene Hexel. All rights reserved.
//
import ECore
import Foundation

// MARK: - Code Generator

/// Actor responsible for generating code from models in various target languages.
///
/// The code generator supports multiple target languages including Swift, C++, C, and LLVM IR.
/// It processes model objects and generates appropriate source code structures.
actor CodeGenerator {
    /// The target language for code generation.
    let language: String

    /// The output directory where generated files will be written.
    let outputDirectory: URL

    /// Initialises a new code generator.
    ///
    /// - Parameters:
    ///   - language: The target language (must be one of: swift, cpp, c, llvm).
    ///   - outputDirectory: The directory where generated files will be written.
    /// - Throws: `GenerationError.unsupportedLanguage` if the language is not supported.
    init(language: String, outputDirectory: URL) throws {
        guard ["swift", "cpp", "c", "llvm"].contains(language) else {
            throw GenerationError.unsupportedLanguage(language)
        }
        self.language = language
        self.outputDirectory = outputDirectory
    }

    /// Generates code from the provided resource.
    ///
    /// - Parameters:
    ///   - resource: The resource containing model objects to generate from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: `GenerationError` if generation fails.
    func generate(from resource: Resource, verbose: Bool) async throws {
        let objects = await resource.getRootObjects()

        if objects.isEmpty {
            if verbose { print("No objects found in model") }
            return
        }

        switch language {
        case "swift":
            try await generateSwift(from: objects, verbose: verbose)
        case "cpp":
            try await generateCpp(from: objects, verbose: verbose)
        case "c":
            try await generateC(from: objects, verbose: verbose)
        case "llvm":
            try await generateLLVM(from: objects, verbose: verbose)
        default:
            throw GenerationError.unsupportedLanguage(language)
        }
    }

    /// Generates Swift code from the provided objects.
    ///
    /// - Parameters:
    ///   - objects: The model objects to generate code from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: File I/O errors if writing fails.
    private func generateSwift(from objects: [any EObject], verbose: Bool) async throws {
        if verbose { print("Generating Swift code...") }

        let outputFile = outputDirectory.appendingPathComponent("Generated.swift")
        var content = """
            //
            // Generated.swift
            // Generated by Swift Ecore
            //
            import Foundation

            """

        for obj in objects {
            if let eClass = obj as? EClass {
                content += generateSwiftClass(from: eClass)
            } else if let ePackage = obj as? EPackage {
                content += generateSwiftPackage(from: ePackage)
            }
        }

        try content.write(to: outputFile, atomically: true, encoding: .utf8)
        if verbose { print("Generated: \(outputFile.path)") }
    }

    /// Generates C++ code from the provided objects.
    ///
    /// - Parameters:
    ///   - objects: The model objects to generate code from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: File I/O errors if writing fails.
    private func generateCpp(from objects: [any EObject], verbose: Bool) async throws {
        if verbose { print("Generating C++ code...") }

        // Header file
        let headerFile = outputDirectory.appendingPathComponent("Generated.hpp")
        var headerContent = """
            //
            // Generated.hpp
            // Generated by Swift Ecore
            //
            #pragma once
            #include <memory>
            #include <string>
            #include <vector>

            """

        // Implementation file
        let implFile = outputDirectory.appendingPathComponent("Generated.cpp")
        var implContent = """
            //
            // Generated.cpp
            // Generated by Swift Ecore
            //
            #include "Generated.hpp"

            """

        for obj in objects {
            if let eClass = obj as? EClass {
                headerContent += generateCppClassHeader(from: eClass)
                implContent += generateCppClassImpl(from: eClass)
            }
        }

        try headerContent.write(to: headerFile, atomically: true, encoding: .utf8)
        try implContent.write(to: implFile, atomically: true, encoding: .utf8)

        if verbose {
            print("Generated: \(headerFile.path)")
            print("Generated: \(implFile.path)")
        }
    }

    /// Generates C code from the provided objects.
    ///
    /// - Parameters:
    ///   - objects: The model objects to generate code from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: File I/O errors if writing fails.
    private func generateC(from objects: [any EObject], verbose: Bool) async throws {
        if verbose { print("Generating C code...") }

        let headerFile = outputDirectory.appendingPathComponent("generated.h")
        let implFile = outputDirectory.appendingPathComponent("generated.c")

        var headerContent = """
            /*
             * generated.h
             * Generated by Swift Ecore
             */
            #ifndef GENERATED_H
            #define GENERATED_H

            """

        let implContent = """
            /*
             * generated.c
             * Generated by Swift Ecore
             */
            #include "generated.h"

            """

        headerContent += "\n#endif /* GENERATED_H */"

        try headerContent.write(to: headerFile, atomically: true, encoding: .utf8)
        try implContent.write(to: implFile, atomically: true, encoding: .utf8)

        if verbose {
            print("Generated: \(headerFile.path)")
            print("Generated: \(implFile.path)")
        }
    }

    /// Generates LLVM IR from the provided objects.
    ///
    /// - Parameters:
    ///   - objects: The model objects to generate code from.
    ///   - verbose: Whether to output verbose progress information.
    /// - Throws: File I/O errors if writing fails.
    private func generateLLVM(from objects: [any EObject], verbose: Bool) async throws {
        if verbose { print("Generating LLVM IR...") }

        let outputFile = outputDirectory.appendingPathComponent("generated.ll")
        let content = """
            ; generated.ll
            ; Generated by Swift Ecore

            """

        try content.write(to: outputFile, atomically: true, encoding: .utf8)
        if verbose { print("Generated: \(outputFile.path)") }
    }

    // MARK: - Swift Generation Helpers

    /// Generates a Swift struct from an EClass.
    ///
    /// - Parameter eClass: The EClass to generate from.
    /// - Returns: Swift code as a string.
    private func generateSwiftClass(from eClass: EClass) -> String {
        var result = """

            struct \(eClass.name) {
            """

        for feature in eClass.eStructuralFeatures {
            if let attribute = feature as? EAttribute {
                let typeName = swiftTypeName(for: attribute.eType as? EDataType)
                result += "\n    var \(attribute.name): \(typeName)?"
            } else if let reference = feature as? EReference {
                let typeName = reference.eType.name
                if reference.upperBound == -1 {
                    result += "\n    var \(reference.name): [\(typeName)] = []"
                } else {
                    result += "\n    var \(reference.name): \(typeName)?"
                }
            }
        }

        result += "\n}\n"
        return result
    }

    /// Generates Swift code from an EPackage.
    ///
    /// - Parameter ePackage: The EPackage to generate from.
    /// - Returns: Swift code as a string.
    private func generateSwiftPackage(from ePackage: EPackage) -> String {
        var result = """

            // Package: \(ePackage.name)
            """

        for classifier in ePackage.eClassifiers {
            if let eClass = classifier as? EClass {
                result += generateSwiftClass(from: eClass)
            }
        }

        return result
    }

    /// Maps an EDataType to a Swift type name.
    ///
    /// - Parameter dataType: The EDataType to map.
    /// - Returns: The corresponding Swift type name.
    private func swiftTypeName(for dataType: EDataType?) -> String {
        guard let dataType = dataType else { return "Any" }

        switch dataType.instanceClassName {
        case "String": return "String"
        case "Int": return "Int"
        case "Bool": return "Bool"
        case "Double": return "Double"
        case "Float": return "Float"
        default: return dataType.name
        }
    }

    // MARK: - C++ Generation Helpers

    /// Generates a C++ class header from an EClass.
    ///
    /// - Parameter eClass: The EClass to generate from.
    /// - Returns: C++ header code as a string.
    private func generateCppClassHeader(from eClass: EClass) -> String {
        var result = """

            class \(eClass.name) {
            public:
            """

        for feature in eClass.eStructuralFeatures {
            if let attribute = feature as? EAttribute {
                let typeName = cppTypeName(for: attribute.eType as? EDataType)
                result +=
                    "\n    \(typeName) get\(attribute.name.capitalized)() const;"
                result +=
                    "\n    void set\(attribute.name.capitalized)(const \(typeName)& value);"
            }
        }

        result += """

            private:
            """

        for feature in eClass.eStructuralFeatures {
            if let attribute = feature as? EAttribute {
                let typeName = cppTypeName(for: attribute.eType as? EDataType)
                result += "\n    \(typeName) \(attribute.name)_;"
            }
        }

        result += "\n};\n"
        return result
    }

    /// Generates C++ class implementation from an EClass.
    ///
    /// - Parameter eClass: The EClass to generate from.
    /// - Returns: C++ implementation code as a string.
    private func generateCppClassImpl(from eClass: EClass) -> String {
        var result = ""

        for feature in eClass.eStructuralFeatures {
            if let attribute = feature as? EAttribute {
                let className = eClass.name
                let attrName = attribute.name
                let typeName = cppTypeName(for: attribute.eType as? EDataType)

                result += """

                    \(typeName) \(className)::get\(attrName.capitalized)() const {
                        return \(attrName)_;
                    }

                    void \(className)::set\(attrName.capitalized)(const \(typeName)& value) {
                        \(attrName)_ = value;
                    }
                    """
            }
        }

        return result
    }

    /// Maps an EDataType to a C++ type name.
    ///
    /// - Parameter dataType: The EDataType to map.
    /// - Returns: The corresponding C++ type name.
    private func cppTypeName(for dataType: EDataType?) -> String {
        guard let dataType = dataType else { return "void*" }

        switch dataType.instanceClassName {
        case "String": return "std::string"
        case "Int": return "int"
        case "Bool": return "bool"
        case "Double": return "double"
        case "Float": return "float"
        default: return dataType.name
        }
    }
}
