#!/bin/bash
echo "=== AQL Complex Patterns: Query Optimisation ==="
echo ""
echo "Techniques for writing efficient AQL queries."
echo ""
echo "❌ INEFFICIENT: Multiple traversals"
echo "  library.books->select(b | b.rating >= 4.0)->size() +"
echo "  library.books->select(b | b.rating >= 4.5)->size() +"
echo "  library.books->select(b | b.rating >= 4.8)->size()"
echo "  Problem: Traverses books collection 3 times"
echo ""
echo "✅ OPTIMISED: Single traversal with let"
echo "  let books = library.books in"
echo "  Tuple{"
echo "    good = books->select(b | b.rating >= 4.0)->size(),"
echo "    great = books->select(b | b.rating >= 4.5)->size(),"
echo "    excellent = books->select(b | b.rating >= 4.8)->size()"
echo "  }"
echo "  Benefit: Evaluates books once, reuses binding"
echo ""
echo "❌ INEFFICIENT: Repeated flatten"
echo "  library.categories->collect(c | c.books)->flatten()->size() +"
echo "  library.categories->collect(c | c.books)->flatten()->select(b | b.available)->size()"
echo "  Problem: Flattens same collection twice"
echo ""
echo "✅ OPTIMISED: Flatten once"
echo "  let allBooks = library.categories->collect(c | c.books)->flatten() in"
echo "  Tuple{"
echo "    total = allBooks->size(),"
echo "    available = allBooks->select(b | b.available)->size()"
echo "  }"
echo ""
echo "❌ INEFFICIENT: Exists with complex condition"
echo "  library.authors->select(a |"
echo "    a.books->exists(b | b.rating >= 4.5 and b.pages > 300)"
echo "  )"
echo "  Problem: Potentially checks all books for each author"
echo ""
echo "✅ OPTIMISED: Pre-filter books"
echo "  let qualifyingBooks = library.books"
echo "    ->select(b | b.rating >= 4.5 and b.pages > 300) in"
echo "  library.authors->select(a |"
echo "    qualifyingBooks->exists(b | b.authors->includes(a))"
echo "  )"
echo "  Benefit: Filter books once, then check membership"
echo ""
echo "❌ INEFFICIENT: Nested collect-flatten"
echo "  library.categories"
echo "    ->collect(c | c.books->collect(b | b.authors)->flatten())"
echo "    ->flatten()->asSet()"
echo "  Problem: Multiple flatten operations"
echo ""
echo "✅ OPTIMISED: Single collectNested"
echo "  library.categories"
echo "    ->collectNested(c | c.books)"
echo "    ->collectNested(b | b.authors)"
echo "    ->asSet()"
echo "  Benefit: More efficient flattening"
echo ""
echo "❌ INEFFICIENT: sortedBy then first()"
echo "  library.books->sortedBy(b | b.rating)->reverse()->first(1)"
echo "  Problem: Sorts entire collection for one element"
echo ""
echo "✅ OPTIMISED: Use max()"
echo "  let maxRating = library.books->collect(b | b.rating)->max() in"
echo "  library.books->select(b | b.rating = maxRating)"
echo "  Benefit: O(n) instead of O(n log n)"
echo ""
echo "Performance Guidelines:"
echo "  1. Minimise collection traversals - use let bindings"
echo "  2. Filter early - reduce set size before expensive operations"
echo "  3. Avoid nested iterations when possible"
echo "  4. Use exists() instead of ->select()->size() > 0"
echo "  5. Prefer direct operations (min/max) over sort-then-select"
echo "  6. Cache intermediate results with let expressions"
echo "  7. Use asSet() to eliminate duplicates early"
echo ""
echo "✅ Optimised queries reduce evaluation time significantly"
echo "✅ Critical for large models with thousands of elements"
