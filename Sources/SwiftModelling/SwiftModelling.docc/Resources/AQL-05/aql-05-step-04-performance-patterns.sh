#!/bin/bash
echo "=== AQL Complex Patterns: Performance Best Practices ==="
echo ""
echo "Patterns for high-performance model queries."
echo ""
echo "Pattern 1: Index Simulation with Let Bindings"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  -- Create 'indexes' for frequently accessed lookups"
echo "  let booksByAuthor = library.authors->collect(a | Tuple{"
echo "    author = a,"
echo "    books = a.books"
echo "  }) in"
echo "  let booksByCategory = library.categories->collect(c | Tuple{"
echo "    category = c,"
echo "    books = c.books"
echo "  }) in"
echo "  -- Now queries use pre-computed collections"
echo "  booksByAuthor->select(t | t.author.name = 'Orwell')->first().books"
echo ""
echo "Pattern 2: Lazy Evaluation with Conditional Logic"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  -- Only compute expensive operations when needed"
echo "  library.books->collect(b | Tuple{"
echo "    title = b.title,"
echo "    rating = b.rating,"
echo "    stats = if b.rating >= 4.5 then"
echo "              Tuple{"
echo "                authors = b.authors->collect(a | a.name),"
echo "                similar = b.similarTo->size(),"
echo "                reviews = b.reviews->size()"
echo "              }"
echo "            else"
echo "              null  -- Skip computation for low-rated books"
echo "            endif"
echo "  })"
echo ""
echo "Pattern 3: Batch Processing with Chunking"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  -- Process large collections in chunks"
echo "  let allBooks = library.books->sortedBy(b | b.title) in"
echo "  let chunk1 = allBooks->subSequence(0, 100) in"
echo "  let chunk2 = allBooks->subSequence(100, 100) in"
echo "  let chunk3 = allBooks->subSequence(200, 100) in"
echo "  Sequence{chunk1, chunk2, chunk3}"
echo "    ->collect(chunk | Tuple{"
echo "      avgRating = chunk->collect(b | b.rating)->sum() / chunk->size(),"
echo "      count = chunk->size()"
echo "    })"
echo ""
echo "Pattern 4: Memoization with Result Caching"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  -- Cache expensive computations"
echo "  let expensiveAuthors = library.authors"
echo "    ->select(a | a.books->size() > 10)  -- Filter first"
echo "    in"
echo "  let authorStats = expensiveAuthors->collect(a | Tuple{"
echo "    author = a.name,"
echo "    totalPages = a.books->collect(b | b.pages)->sum(),"
echo "    avgRating = a.books->collect(b | b.rating)->sum() / a.books->size()"
echo "  }) in"
echo "  -- Reuse authorStats for multiple queries"
echo "  Tuple{"
echo "    topByPages = authorStats->sortedBy(t | t.totalPages)->reverse()->first(),"
echo "    topByRating = authorStats->sortedBy(t | t.avgRating)->reverse()->first()"
echo "  }"
echo ""
echo "Pattern 5: Short-Circuit Evaluation"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  -- Use exists() to stop early"
echo "  library.books->exists(b | b.rating >= 4.8 and b.available)"
echo "  -- Stops at first match (vs. ->select()->size() > 0)"
echo ""
echo "  -- Combine with forAll() for validation"
echo "  library.books->forAll(b | b.pages > 0)  -- Stops at first violation"
echo ""
echo "Pattern 6: Set Operations for Deduplication"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  -- Remove duplicates early in pipeline"
echo "  library.categories"
echo "    ->collect(c | c.books)->flatten()"
echo "    ->asSet()  -- Deduplicate immediately"
echo "    ->collect(b | b.authors)->flatten()"
echo "    ->asSet()  -- Deduplicate again"
echo "  -- vs. deduplicating at the end (processes more elements)"
echo ""
echo "Pattern 7: Projection to Reduce Data Size"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  -- Extract only needed fields early"
echo "  let bookTitles = library.books->collect(b | b.title) in"
echo "  -- Work with strings instead of full objects"
echo "  bookTitles->select(t | t.startsWith('The'))->sortedBy(t | t)"
echo ""
echo "Pattern 8: Avoid Cartesian Products"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  ❌ library.authors->collect(a |"
echo "      library.books->collect(b | Tuple{author=a, book=b})"
echo "    )->flatten()"
echo "  -- Creates N*M tuples"
echo ""
echo "  ✅ library.authors->collect(a | Tuple{"
echo "      author = a.name,"
echo "      books = a.books->collect(b | b.title)"
echo "    })"
echo "  -- Creates only N tuples with nested data"
echo ""
echo "Performance Checklist:"
echo "  ✓ Use let bindings to avoid recomputation"
echo "  ✓ Filter collections early in the pipeline"
echo "  ✓ Prefer exists()/forAll() over select()->size()"
echo "  ✓ Use asSet() to deduplicate early"
echo "  ✓ Project to minimal data (collect only needed fields)"
echo "  ✓ Avoid unnecessary Cartesian products"
echo "  ✓ Cache intermediate results for reuse"
echo "  ✓ Use direct operations (min/max) instead of sort"
echo ""
echo "✅ Performance patterns enable queries on large models"
echo "✅ Critical for production Model-Driven Engineering systems"
