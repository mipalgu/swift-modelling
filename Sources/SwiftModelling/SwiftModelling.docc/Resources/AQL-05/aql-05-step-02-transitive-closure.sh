#!/bin/bash
echo "=== AQL Complex Patterns: Transitive Closure ==="
echo ""
echo "Compute transitive relationships efficiently."
echo ""
echo "Ex 1: Basic closure"
echo "  -- Assume Person metamodel with 'friends' reference"
echo "  person->closure(p | p.friends)"
echo "  Result: Person and all friends, friends of friends, etc."
echo ""
echo "Ex 2: Closure with filtering"
echo "  -- Find all related books through 'similarTo' references"
echo "  book->closure(b | b.similarTo->select(s | s.rating >= 4.0))"
echo "  Result: Book and all highly-rated similar books transitively"
echo ""
echo "Ex 3: Closure depth limit (manual)"
echo "  -- Two-hop closure manually"
echo "  let hop1 = book.similarTo in"
echo "  let hop2 = hop1->collect(b | b.similarTo)->flatten()->asSet() in"
echo "  hop1->union(hop2)->including(book)"
echo "  Result: Book and similar books up to 2 hops away"
echo ""
echo "Ex 4: Category hierarchy with closure"
echo "  -- If Category has 'subcategories' reference:"
echo "  rootCategory->closure(c | c.subcategories)"
echo "  Result: All categories in the hierarchy"
echo ""
echo "  rootCategory->closure(c | c.subcategories)"
echo "    ->collect(c | c.books)->flatten()"
echo "  Result: All books in category hierarchy"
echo ""
echo "Ex 5: Reachability check"
echo "  -- Check if author2 is reachable from author1 through co-authorship"
echo "  let author1 = library.authors->first() in"
echo "  let author2 = library.authors->last() in"
echo "  let network = author1->closure(a |"
echo "    a.books->collect(b | b.authors)->flatten()->asSet()"
echo "  ) in"
echo "  network->includes(author2)"
echo "  Result: true if author2 in author1's collaboration network"
echo ""
echo "Ex 6: Shortest path (BFS approximation)"
echo "  -- Manual breadth-first traversal (limited depth)"
echo "  let start = library.books->first() in"
echo "  let target = library.books->last() in"
echo "  let level0 = Set{start} in"
echo "  let level1 = level0->collect(b | b.similarTo)->flatten()->asSet() in"
echo "  let level2 = level1->collect(b | b.similarTo)->flatten()->asSet() in"
echo "  if level1->includes(target) then 1"
echo "  else if level2->includes(target) then 2"
echo "  else -1"  -- Not found within 2 hops
echo "  endif endif"
echo "  Result: Distance from start to target (1, 2, or -1)"
echo ""
echo "Ex 7: Closure with cycle detection"
echo "  -- Track visited to avoid infinite loops (conceptual)"
echo "  -- Note: AQL closure() handles cycles automatically"
echo "  library.categories->first()"
echo "    ->closure(c | c.subcategories)"
echo "    ->collect(c | Tuple{name = c.name, depth = 'varies'})"
echo "  Result: All reachable categories (cycles handled)"
echo ""
echo "✅ closure() automatically handles cycles"
echo "✅ Essential for graph-like model structures"
echo "✅ Enables reachability and network analysis"
