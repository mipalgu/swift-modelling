-- @atlcompiler atl2010
-- @path Blogv1=/workflow-03-step-01-original-metamodel.ecore
-- @path Blogv2=/workflow-03-step-02-evolved-metamodel.ecore

-- Migration transformation from Blog v1 to Blog v2
-- Demonstrates metamodel evolution patterns:
-- - Adding new attributes with default values
-- - Adding new classes (Category, Tag)
-- - Deriving new attribute values from existing data
-- - Maintaining backward compatibility

module Blog1to2;

create OUT : Blogv2 from IN : Blogv1;

-- Helper: Generate URL-friendly slug from title
helper context String def: toSlug() : String =
	self.toLower()
		.regexReplaceAll('[^a-z0-9]+', '-')
		.regexReplaceAll('^-+|-+$', '');

-- Helper: Infer category name from post content/title
helper context Blogv1!Post def: inferCategory() : String =
	if self.title.toLower().indexOf('tutorial') >= 0 or
	   self.content.toLower().indexOf('tutorial') >= 0 then
		'Tutorials'
	else if self.title.toLower().indexOf('news') >= 0 or
	        self.content.toLower().indexOf('announcement') >= 0 then
		'News'
	else if self.title.toLower().indexOf('review') >= 0 then
		'Reviews'
	else
		'General'
	endif endif endif;

-- Helper: Extract potential tags from content
helper context Blogv1!Post def: extractTags() : Sequence(String) =
	Sequence{'blog', 'post'}; -- Simplified tag extraction

-- Main rule: Migrate Blog with new collections
rule Blog2Blog {
	from
		b1 : Blogv1!Blog
	to
		b2 : Blogv2!Blog (
			name <- b1.name,
			description <- b1.description,
			url <- b1.url,
			posts <- b1.posts,
			authors <- b1.authors,
			categories <- b1.posts->collect(p | p.inferCategory())
				->asSet()
				->collect(name | thisModule.createCategory(name)),
			tags <- b1.posts->collect(p | p.extractTags())
				->flatten()
				->asSet()
				->collect(name | thisModule.createTag(name))
		)
}

-- Rule: Migrate Post with new attributes and relationships
rule Post2Post {
	from
		p1 : Blogv1!Post
	to
		p2 : Blogv2!Post (
			title <- p1.title,
			content <- p1.content,
			publishDate <- p1.publishDate,
			-- New v2 attributes with derived values
			slug <- p1.title.toSlug(),
			viewCount <- 0,
			published <- true, -- Assume existing posts are published
			author <- p1.author,
			comments <- p1.comments,
			category <- thisModule.resolveTemp(
				thisModule.getCategoryByName(p1.inferCategory()),
				'c2'
			),
			tags <- p1.extractTags()->collect(name |
				thisModule.resolveTemp(
					thisModule.getTagByName(name),
					't2'
				)
			)
		)
}

-- Rule: Migrate Author with new attributes
rule Author2Author {
	from
		a1 : Blogv1!Author
	to
		a2 : Blogv2!Author (
			name <- a1.name,
			email <- a1.email,
			-- New v2 attributes with default values
			bio <- 'Author profile coming soon.',
			avatarUrl <- 'https://www.example.org/avatars/default.png'
		)
}

-- Rule: Migrate Comment (unchanged structure)
rule Comment2Comment {
	from
		c1 : Blogv1!Comment
	to
		c2 : Blogv2!Comment (
			authorName <- c1.authorName,
			content <- c1.content,
			date <- c1.date
		)
}

-- Lazy rule: Create Category on demand
lazy rule CreateCategory {
	from
		name : String
	to
		c2 : Blogv2!Category (
			name <- name,
			description <- 'Posts in the ' + name + ' category.'
		)
}

-- Lazy rule: Create Tag on demand
lazy rule CreateTag {
	from
		name : String
	to
		t2 : Blogv2!Tag (
			name <- name
		)
}

-- Helper: Create category from name
helper def: createCategory(name : String) : Blogv2!Category =
	thisModule.CreateCategory(name);

-- Helper: Create tag from name
helper def: createTag(name : String) : Blogv2!Tag =
	thisModule.CreateTag(name);

-- Helper: Get category by name (for resolution)
helper def: getCategoryByName(name : String) : String =
	name;

-- Helper: Get tag by name (for resolution)
helper def: getTagByName(name : String) : String =
	name;
