[comment encoding = UTF-8 /]
[comment]
  MTL Template: Generate REST API from Ecore Metamodel
  Creates OpenAPI specification and server stubs
  Part of the Cross-Format Integration tutorial
[/comment]

[module GenerateRestAPI('http://www.eclipse.org/emf/2002/Ecore')]

[comment Main entry point /]
[template public generate(pkg : EPackage)]
[comment Generate OpenAPI specification /]
[file ('openapi.yaml', false, 'UTF-8')]
[generateOpenAPISpec(pkg)/]
[/file]

[comment Generate server routes /]
[file ('routes.swift', false, 'UTF-8')]
[generateServerRoutes(pkg)/]
[/file]

[comment Generate request/response DTOs /]
[file ('DTOs.swift', false, 'UTF-8')]
[generateDTOs(pkg)/]
[/file]
[/template]

[comment Generate OpenAPI 3.0 specification /]
[template private generateOpenAPISpec(pkg : EPackage)]
# OpenAPI Specification for [pkg.name/] API
# Generated from [pkg.name/].ecore
# Do not edit manually - changes will be overwritten

openapi: "3.0.3"
info:
  title: [pkg.name/] API
  description: REST API for [pkg.name/] model management
  version: "1.0.0"
  contact:
    name: API Support
    email: api-support@acme.com.au

servers:
  - url: https://api.acme.com.au/v1
    description: Production server
  - url: https://api-staging.acme.com.au/v1
    description: Staging server

paths:
[for (cls : EClass | pkg.eClassifiers->filter(EClass))]
[generatePathsForClass(cls)/]
[/for]

  /sync/status:
    get:
      summary: Get synchronisation status
      operationId: getSyncStatus
      tags: ['['/]Synchronisation[']'/]
      responses:
        '200':
          description: Current synchronisation status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SyncStatus'

  /sync/push:
    post:
      summary: Push local changes
      operationId: pushChanges
      tags: ['['/]Synchronisation[']'/]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ChangeSet'
      responses:
        '200':
          description: Changes pushed successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PushResult'
        '409':
          description: Conflict detected
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ConflictReport'

  /sync/pull:
    get:
      summary: Pull remote changes
      operationId: pullChanges
      tags: ['['/]Synchronisation[']'/]
      parameters:
        - name: since
          in: query
          description: Timestamp of last sync
          schema:
            type: string
            format: date-time
      responses:
        '200':
          description: Remote changes retrieved
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChangeSet'

  /export/xmi:
    get:
      summary: Export model as XMI
      operationId: exportXMI
      tags: ['['/]Export[']'/]
      responses:
        '200':
          description: XMI export
          content:
            application/xml:
              schema:
                type: string

  /export/json:
    get:
      summary: Export model as JSON
      operationId: exportJSON
      tags: ['['/]Export[']'/]
      responses:
        '200':
          description: JSON export
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Organisation'

components:
  schemas:
[for (cls : EClass | pkg.eClassifiers->filter(EClass))]
[generateSchemaForClass(cls)/]
[/for]
[for (enum : EEnum | pkg.eClassifiers->filter(EEnum))]
[generateSchemaForEnum(enum)/]
[/for]

    SyncStatus:
      type: object
      properties:
        lastSync:
          type: string
          format: date-time
        pendingChanges:
          type: integer
        conflicts:
          type: integer
        status:
          type: string
          enum: ['['/]SYNCED[']'/], ['['/]PENDING[']'/], ['['/]CONFLICT[']'/]

    ChangeSet:
      type: object
      properties:
        timestamp:
          type: string
          format: date-time
        source:
          type: string
        changes:
          type: array
          items:
            $ref: '#/components/schemas/Change'

    Change:
      type: object
      properties:
        id:
          type: string
        type:
          type: string
          enum: ['['/]ADD[']'/], ['['/]UPDATE[']'/], ['['/]DELETE[']'/]
        elementType:
          type: string
        elementId:
          type: string
        properties:
          type: object
          additionalProperties: true

    PushResult:
      type: object
      properties:
        success:
          type: boolean
        changesApplied:
          type: integer
        newVersion:
          type: string

    ConflictReport:
      type: object
      properties:
        conflicts:
          type: array
          items:
            $ref: '#/components/schemas/Conflict'

    Conflict:
      type: object
      properties:
        elementId:
          type: string
        elementType:
          type: string
        localChange:
          $ref: '#/components/schemas/Change'
        remoteChange:
          $ref: '#/components/schemas/Change'

  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

security:
  - bearerAuth: ['['/][']'/]
[/template]

[comment Generate paths for a class /]
[template private generatePathsForClass(cls : EClass)]
  /[cls.name.toLower()/]s:
    get:
      summary: List all [cls.name.toLower()/]s
      operationId: list[cls.name/]s
      tags: ['['/][cls.name/][']'/]
      parameters:
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
        - name: offset
          in: query
          schema:
            type: integer
            default: 0
      responses:
        '200':
          description: List of [cls.name.toLower()/]s
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items:
                      $ref: '#/components/schemas/[cls.name/]'
                  total:
                    type: integer
    post:
      summary: Create a new [cls.name.toLower()/]
      operationId: create[cls.name/]
      tags: ['['/][cls.name/][']'/]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/[cls.name/]Input'
      responses:
        '201':
          description: [cls.name/] created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/[cls.name/]'

  /[cls.name.toLower()/]s/{id}:
    get:
      summary: Get [cls.name.toLower()/] by ID
      operationId: get[cls.name/]
      tags: ['['/][cls.name/][']'/]
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: [cls.name/] details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/[cls.name/]'
        '404':
          description: [cls.name/] not found
    put:
      summary: Update [cls.name.toLower()/]
      operationId: update[cls.name/]
      tags: ['['/][cls.name/][']'/]
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/[cls.name/]Input'
      responses:
        '200':
          description: [cls.name/] updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/[cls.name/]'
    delete:
      summary: Delete [cls.name.toLower()/]
      operationId: delete[cls.name/]
      tags: ['['/][cls.name/][']'/]
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '204':
          description: [cls.name/] deleted

[/template]

[comment Generate schema for a class /]
[template private generateSchemaForClass(cls : EClass)]
    [cls.name/]:
      type: object
      properties:
[for (attr : EAttribute | cls.eAllAttributes)]
        [attr.name/]:
          [attr.openAPIType()/]
[/for]
[for (ref : EReference | cls.eAllReferences->select(r | not r.containment))]
        [ref.name/]Id[if (ref.upperBound <> 1)]s[/if]:
          [ref.openAPIRefType()/]
[/for]
[for (ref : EReference | cls.eAllReferences->select(r | r.containment))]
        [ref.name/]:
          [ref.openAPIContainmentType()/]
[/for]

    [cls.name/]Input:
      type: object
      properties:
[for (attr : EAttribute | cls.eAllAttributes->select(a | a.name <> 'id'))]
        [attr.name/]:
          [attr.openAPIType()/]
[/for]
[for (ref : EReference | cls.eAllReferences->select(r | not r.containment))]
        [ref.name/]Id[if (ref.upperBound <> 1)]s[/if]:
          [ref.openAPIRefType()/]
[/for]
      required:
[for (attr : EAttribute | cls.eAllAttributes->select(a | a.lowerBound > 0 and a.name <> 'id'))]
        - [attr.name/]
[/for]

[/template]

[comment Generate schema for an enum /]
[template private generateSchemaForEnum(enum : EEnum)]
    [enum.name/]:
      type: string
      enum:
[for (literal : EEnumLiteral | enum.eLiterals)]
        - [literal.name/]
[/for]

[/template]

[comment Map attribute to OpenAPI type /]
[query private openAPIType(attr : EAttribute) : String =
    if attr.eType.name = 'EString' then 'type: string'
    else if attr.eType.name = 'EInt' then 'type: integer'
    else if attr.eType.name = 'EDouble' then 'type: number\n          format: double'
    else if attr.eType.name = 'EBoolean' then 'type: boolean'
    else if attr.eType.name = 'EDate' then 'type: string\n          format: date'
    else if attr.eType.oclIsKindOf(EEnum) then '$ref: \'#/components/schemas/' + attr.eType.name + '\''
    else 'type: string'
    endif endif endif endif endif endif
/]

[comment Map reference to OpenAPI type /]
[query private openAPIRefType(ref : EReference) : String =
    if ref.upperBound = 1 then 'type: string'
    else 'type: array\n          items:\n            type: string'
    endif
/]

[comment Map containment to OpenAPI type /]
[query private openAPIContainmentType(ref : EReference) : String =
    if ref.upperBound = 1 then '$ref: \'#/components/schemas/' + ref.eType.name + '\''
    else 'type: array\n          items:\n            $ref: \'#/components/schemas/' + ref.eType.name + '\''
    endif
/]

[comment Generate server routes /]
[template private generateServerRoutes(pkg : EPackage)]
// routes.swift
// Generated from [pkg.name/].ecore
// Vapor server routes for [pkg.name/] API

import Vapor

/// Configure all routes for the [pkg.name/] API
func configureRoutes(_ app: Application) throws {
    // API version prefix
    let api = app.grouped("v1")

    // Configure CORS
    let cors = CORSMiddleware(configuration: .default())
    api.middleware.use(cors)

    // Authentication middleware
    let protected = api.grouped(JWTAuthMiddleware())

[for (cls : EClass | pkg.eClassifiers->filter(EClass))]
    // [cls.name/] routes
    configure[cls.name/]Routes(protected)

[/for]
    // Synchronisation routes
    configureSyncRoutes(protected)

    // Export routes
    configureExportRoutes(protected)
}

[for (cls : EClass | pkg.eClassifiers->filter(EClass))]
[generateRoutesForClass(cls)/]
[/for]

/// Configure synchronisation routes
func configureSyncRoutes(_ routes: RoutesBuilder) {
    let sync = routes.grouped("sync")

    sync.get("status") { req async throws -> SyncStatusDTO in
        let service = try req.make(SyncService.self)
        return try await service.getStatus()
    }

    sync.post("push") { req async throws -> PushResultDTO in
        let changeSet = try req.content.decode(ChangeSetDTO.self)
        let service = try req.make(SyncService.self)
        return try await service.pushChanges(changeSet)
    }

    sync.get("pull") { req async throws -> ChangeSetDTO in
        let since = req.query[String.self, at: "since"]
        let service = try req.make(SyncService.self)
        return try await service.pullChanges(since: since)
    }
}

/// Configure export routes
func configureExportRoutes(_ routes: RoutesBuilder) {
    let export = routes.grouped("export")

    export.get("xmi") { req async throws -> Response in
        let service = try req.make(ExportService.self)
        let xmi = try await service.exportXMI()
        return Response(
            status: .ok,
            headers: ["Content-Type": "application/xml"],
            body: .init(string: xmi)
        )
    }

    export.get("json") { req async throws -> OrganisationDTO in
        let service = try req.make(ExportService.self)
        return try await service.exportJSON()
    }
}
[/template]

[comment Generate routes for a class /]
[template private generateRoutesForClass(cls : EClass)]
/// Configure [cls.name/] routes
func configure[cls.name/]Routes(_ routes: RoutesBuilder) {
    let [cls.name.toLowerFirst()/]s = routes.grouped("[cls.name.toLower()/]s")

    // List all [cls.name.toLower()/]s
    [cls.name.toLowerFirst()/]s.get { req async throws -> Page<[cls.name/]DTO> in
        let service = try req.make([cls.name/]Service.self)
        let limit = req.query[Int.self, at: "limit"] ?? 20
        let offset = req.query[Int.self, at: "offset"] ?? 0
        return try await service.list(limit: limit, offset: offset)
    }

    // Get [cls.name.toLower()/] by ID
    [cls.name.toLowerFirst()/]s.get(":id") { req async throws -> [cls.name/]DTO in
        guard let id = req.parameters.get("id") else {
            throw Abort(.badRequest, reason: "Missing ID parameter")
        }
        let service = try req.make([cls.name/]Service.self)
        guard let [cls.name.toLowerFirst()/] = try await service.find(id: id) else {
            throw Abort(.notFound, reason: "[cls.name/] not found")
        }
        return [cls.name.toLowerFirst()/]
    }

    // Create new [cls.name.toLower()/]
    [cls.name.toLowerFirst()/]s.post { req async throws -> [cls.name/]DTO in
        let input = try req.content.decode([cls.name/]InputDTO.self)
        let service = try req.make([cls.name/]Service.self)
        return try await service.create(input)
    }

    // Update [cls.name.toLower()/]
    [cls.name.toLowerFirst()/]s.put(":id") { req async throws -> [cls.name/]DTO in
        guard let id = req.parameters.get("id") else {
            throw Abort(.badRequest, reason: "Missing ID parameter")
        }
        let input = try req.content.decode([cls.name/]InputDTO.self)
        let service = try req.make([cls.name/]Service.self)
        return try await service.update(id: id, input: input)
    }

    // Delete [cls.name.toLower()/]
    [cls.name.toLowerFirst()/]s.delete(":id") { req async throws -> HTTPStatus in
        guard let id = req.parameters.get("id") else {
            throw Abort(.badRequest, reason: "Missing ID parameter")
        }
        let service = try req.make([cls.name/]Service.self)
        try await service.delete(id: id)
        return .noContent
    }
}

[/template]

[comment Generate DTOs /]
[template private generateDTOs(pkg : EPackage)]
// DTOs.swift
// Generated from [pkg.name/].ecore
// Data Transfer Objects for [pkg.name/] API

import Vapor

[for (cls : EClass | pkg.eClassifiers->filter(EClass))]
[generateDTOForClass(cls)/]
[/for]

// MARK: - Synchronisation DTOs

struct SyncStatusDTO: Content {
    let lastSync: Date?
    let pendingChanges: Int
    let conflicts: Int
    let status: SyncState
}

enum SyncState: String, Content {
    case synced = "SYNCED"
    case pending = "PENDING"
    case conflict = "CONFLICT"
}

struct ChangeSetDTO: Content {
    let timestamp: Date
    let source: String
    let changes: [ChangeDTO]
}

struct ChangeDTO: Content {
    let id: String
    let type: ChangeType
    let elementType: String
    let elementId: String
    let properties: [String: AnyCodable]
}

enum ChangeType: String, Content {
    case add = "ADD"
    case update = "UPDATE"
    case delete = "DELETE"
}

struct PushResultDTO: Content {
    let success: Bool
    let changesApplied: Int
    let newVersion: String
}

struct ConflictReportDTO: Content {
    let conflicts: [ConflictDTO]
}

struct ConflictDTO: Content {
    let elementId: String
    let elementType: String
    let localChange: ChangeDTO
    let remoteChange: ChangeDTO
}

// MARK: - Pagination

struct Page<T: Content>: Content {
    let items: [T]
    let total: Int
}

// MARK: - AnyCodable for dynamic properties

struct AnyCodable: Codable {
    let value: Any

    init(_ value: Any) {
        self.value = value
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let string = try? container.decode(String.self) {
            value = string
        } else if let int = try? container.decode(Int.self) {
            value = int
        } else if let double = try? container.decode(Double.self) {
            value = double
        } else if let bool = try? container.decode(Bool.self) {
            value = bool
        } else {
            value = ""
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let string = value as? String {
            try container.encode(string)
        } else if let int = value as? Int {
            try container.encode(int)
        } else if let double = value as? Double {
            try container.encode(double)
        } else if let bool = value as? Bool {
            try container.encode(bool)
        }
    }
}
[/template]

[comment Generate DTO for a class /]
[template private generateDTOForClass(cls : EClass)]
// MARK: - [cls.name/] DTOs

struct [cls.name/]DTO: Content, Identifiable {
[for (attr : EAttribute | cls.eAllAttributes)]
    let [attr.name/]: [attr.swiftDTOType()/]
[/for]
[for (ref : EReference | cls.eAllReferences->select(r | not r.containment))]
    let [ref.name/]Id[if (ref.upperBound <> 1)]s[/if]: [ref.swiftRefDTOType()/]
[/for]
[for (ref : EReference | cls.eAllReferences->select(r | r.containment))]
    let [ref.name/]: [ref.swiftContainmentDTOType()/]
[/for]
}

struct [cls.name/]InputDTO: Content {
[for (attr : EAttribute | cls.eAllAttributes->select(a | a.name <> 'id'))]
    [if (attr.lowerBound > 0)]let[else]var[/if] [attr.name/]: [attr.swiftDTOType()/]
[/for]
[for (ref : EReference | cls.eAllReferences->select(r | not r.containment))]
    var [ref.name/]Id[if (ref.upperBound <> 1)]s[/if]: [ref.swiftRefDTOType()/]
[/for]
}

[/template]

[comment Map attribute to Swift DTO type /]
[query private swiftDTOType(attr : EAttribute) : String =
    if attr.eType.name = 'EString' then
        if attr.lowerBound > 0 then 'String' else 'String?' endif
    else if attr.eType.name = 'EInt' then
        if attr.lowerBound > 0 then 'Int' else 'Int?' endif
    else if attr.eType.name = 'EDouble' then
        if attr.lowerBound > 0 then 'Double' else 'Double?' endif
    else if attr.eType.name = 'EBoolean' then
        if attr.lowerBound > 0 then 'Bool' else 'Bool?' endif
    else if attr.eType.name = 'EDate' then
        if attr.lowerBound > 0 then 'Date' else 'Date?' endif
    else if attr.eType.oclIsKindOf(EEnum) then
        if attr.lowerBound > 0 then attr.eType.name else attr.eType.name + '?' endif
    else 'String'
    endif endif endif endif endif endif
/]

[comment Map reference to Swift DTO type /]
[query private swiftRefDTOType(ref : EReference) : String =
    if ref.upperBound = 1 then
        if ref.lowerBound > 0 then 'String' else 'String?' endif
    else '[String]'
    endif
/]

[comment Map containment to Swift DTO type /]
[query private swiftContainmentDTOType(ref : EReference) : String =
    if ref.upperBound = 1 then
        if ref.lowerBound > 0 then ref.eType.name + 'DTO' else ref.eType.name + 'DTO?' endif
    else '[' + ref.eType.name + 'DTO]'
    endif
/]
